\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{デバイス} 
\label{ch:device}

\begin{content}

\end{content}

\section{デバイス仕様}

\begin{content}

デバイス仕様\ascii{(Device Specification)}は\ascii{OP}ストレージまたは計算デバイスの具体的な位置を記述するために使用されます。

\subsection{形式化}

デバイス仕様は形式的に次のように記述できます：

\begin{leftbar}
\begin{python}
DEVICE_SPEC ::= COLOCATED_NODE | PARTIAL_SPEC
COLOCATED_NODE ::= "@" NODE_NAME
PARTIAL_SPEC ::= ("/" CONSTRAINT) *
CONSTRAINT ::= ("job:" JOB_NAME)
             | ("replica:" [1-9][0-9]*)
             | ("task:" [1-9][0-9]*)
             | ( ("gpu" | "cpu") ":" ([1-9][0-9]* | "*") )
\end{python}
\end{leftbar}

\subsubsection{完全指定}

以下の例は、ある\ascii{OP}が\ascii{PS}ジョブ、\ascii{0}番目のレプリカ、\ascii{0}番目のタスク、\ascii{GPU 0}番デバイスに配置されることを完全に記述しています。

\begin{leftbar}
\begin{python}
/job:ps/replica:0/task:0/device:GPU:0
\end{python}
\end{leftbar}

\subsubsection{部分指定}

デバイス仕様は部分的に指定することもでき、空であることもあります。例えば、以下は\code{GPU0}番デバイスのみを記述しています。

\begin{leftbar}
\begin{python}
/device:GPU:0
\end{python}
\end{leftbar}

特に、デバイス仕様が空の場合、\ascii{OP}にデバイス制約が課されていないことを示し、実行時に自動的にデバイスが選択され\ascii{OP}が配置されます。

\subsubsection{並置}

\code{COLOCATED\_NODE}を使用して、その\ascii{OP}が指定されたノードと同じデバイス上に配置されることを示します。例えば、このノードは\code{other/node}と同じデバイス上に配置されます。

\begin{leftbar}
\begin{python}
@other/node  # colocate with "other/node"
\end{python}
\end{leftbar}

\subsubsection{DeviceSpec}

デバイス仕様は文字列または\code{DeviceSpec}で表現できます。\code{DeviceSpec}は値オブジェクトで、以下の\ascii{5}つの識別子を使用してデバイス仕様を決定します。

\begin{enum}
  \eitem{ジョブ名}
  \eitem{レプリカ識別子}
  \eitem{タスク識別子}
  \eitem{デバイスタイプ}
  \eitem{デバイス識別子}
\end{enum}

例えば、\code{DeviceSpec}を使用して構築されたデバイス仕様：

\begin{leftbar}
\begin{python}
# '/job:ps/replica:0/task:0/device:CPU:0'
DeviceSpec(job="ps", replica=0, task=0, device_type="CPU", device_index=0)
\end{python}
\end{leftbar}

\subsection{コンテキストマネージャ}

\ascii{OP}のデバイス仕様を指定するために、コンテキストマネージャ\code{device(device\_spec)}がよく使用されます。このコンテキストのスコープ内で構築された\code{OP}は、実行時に指定されたデバイス上で実行されます。

\begin{leftbar}
\begin{python}
with g.device('/gpu:0'):
  # All OPs constructed here will be placed on GPU 0.
\end{python}
\end{leftbar}

ここで、\code{device}は\code{Graph}のメソッドで、スタック式構造のコンテキストマネージャを設計し、デバイス仕様のクロージャ、マージ、オーバーライドなどの特性を実現しています。

\subsubsection{マージ}

異なる範囲の2つのデバイス仕様をマージすることができます。

\begin{leftbar}
\begin{python}
with device("/job:ps"):
  # All OPs constructed here will be placed on PS.
  with device("/task:0/device:GPU:0"):
    # All OPs constructed here will be placed on
    # /job:ps/task:0/device:GPU:0
\end{python}
\end{leftbar}

\subsubsection{オーバーライド}

同じ範囲の2つのデバイス仕様をマージする際、内部で指定されているデバイス仕様が高い優先順位を持ち、デバイス仕様をオーバーライドします。

\begin{leftbar}
\begin{python}
with device("/device:CPU:0"):
  # All OPs constructed here will be placed on CPU 0.
  with device("/job:ps/device:GPU:0"):
    # All OPs constructed here will be placed on
    # /job:ps/device:GPU:0
\end{python}
\end{leftbar}

\subsubsection{リセット}

特に、内部のデバイス仕様が\code{None}に設定されている場合、外部のすべてのデバイス仕様の定義は無視されます。

\begin{leftbar}
\begin{python}
with device("/device:GPU:0"):
  # All OPs constructed here will be placed on CPU 0.
  with device(None):
    # /device:GPU:0 will be ignored.
\end{python}
\end{leftbar}

\subsubsection{デバイス仕様関数}

デバイス仕様を指定する際、通常は文字列や\code{DeviceSpec}を使用して記述します。より柔軟な\emph{デバイス仕様関数}を使用することもできます。これはデバイス仕様を指定するためのより柔軟な拡張方法を提供します。デバイス仕様関数はコールバック関数で、\code{Operation}を引数として受け取り、文字列形式のデバイス仕様を生成します。

\begin{leftbar}
\begin{python}
def matmul_on_gpu(n):
 if n.type == "MatMul":
   return "/gpu:0"
 else:
   return "/cpu:0"

with g.device(matmul_on_gpu):
  # All OPs of type "MatMul" constructed in this context
  # will be placed on GPU 0; all other OPs will be placed
  # on CPU 0.
\end{python}
\end{leftbar}

\subsubsection{実装}

\code{Graph.device(spec)}はスタック式構造のコンテキストマネージャを実装しており、文字列形式のデバイス仕様または\emph{デバイス仕様関数}を受け入れることができます。実際、\code{device}関数に文字列または\code{DeviceSpec}を渡すと、まずその文字列または\code{DeviceSpec}に対して簡単な変換を行い、統一的にデバイス仕様関数に変換します。

\begin{leftbar}
\begin{python}
class Graph(object):
  def device(self, device_name_or_func):
    def to_device_func():
      if (device_name_or_func is not None
          and not callable(device_name_or_func)):
        return pydev.merge_device(device_name_or_func)
      else:
        return device_name_or_func

    try:
      self._device_function_stack.append(to_device_func())
      yield
    finally:
      self._device_function_stack.pop()
\end{python}
\end{leftbar}

ユーザーが\code{device}を使用する際に明示的にグラフインスタンスを指定しない場合、グローバルに一意な標準グラフインスタンスが暗黙的に使用されます。つまり、\code{tf.device(spec)}関数は実際には\code{get\_default\_graph().device(spec)}の単純なラッパーです。

\begin{leftbar}
\begin{python}
# tensorflow/python/framework/ops.py
def device(device_name_or_function):
  return get_default_graph().device(device_name_or_function)
\end{python}
\end{leftbar}

\subsubsection{適用}

\code{Graph.device}の実装では、\code{pydev.merge\_device}がデバイス仕様関数を生成します。このデバイス関数は入力された\code{spec}で新しいコピーを作成し、\code{copy\_spec.merge\_from(current\_device)}を呼び出して既存の\code{node\_def.device}デバイス仕様をマージし、\code{node\_def.device}がより高い優先順位を持ちます。実装はやや複雑ですが、なぜ\code{node\_def.device}がより高い優先順位を持つのでしょうか？これは\code{\_apply\_device\_functions}がオーバーライド、マージ、リセットの要件を実装しているためです。

\begin{leftbar}
\begin{python}
def merge_device(spec):
  # replace string to DeviceSpec
  if not isinstance(spec, DeviceSpec):
    spec = DeviceSpec.from_string(spec or "")

  # returns a device function that merges devices specifications
  def _device_function(node_def):
    current_device = DeviceSpec.from_string(node_def.device or "")
    copy_spec = copy.copy(spec)

    # IMPORTANT: `node\_def.device` takes precedence.
    copy_spec.merge_from(current_device)      
    return copy_spec
  return _device_function
\end{python}
\end{leftbar}

\code{Graph.create\_op}時に、\code{\_apply\_device\_functions}が呼び出されて\code{NodeDef}のデバイス仕様が設定されます。これは\code{\_device\_function\_stack}に対して順次スタック操作を実行し、対応するデバイス仕様関数を呼び出し、結果を直接\code{NodeDef}のデバイス仕様として設定します。このように、内部で指定された\code{device}がより高い優先順位を持ち、外部で指定された\code{device}のマージ、オーバーライド、リセットを実現します。

\begin{leftbar}
\begin{python}
class Graph(object):
  def _apply_device_functions(self, op):
    for device_function in reversed(self._device_function_stack):
      if device_function is None:
        break
      # IMPORTANT: `node\_def.device` takes precedence. 
      op._set_device(device_function(op))
\end{python}
\end{leftbar}

\end{content}
