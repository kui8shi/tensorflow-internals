\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{セッション} 
\label{ch:session}

\begin{content}

クライアントは\code{Session}を橋渡しとして、バックエンドの計算エンジンとの接続を確立し、計算グラフの実行プロセスを開始します。\code{Session.run}を呼び出すことで、\ascii{TensorFlow}の1回の計算\ascii{(Step)}がトリガーされます。

実際、\code{Session}は計算グラフを実行するためのクロージャー環境を確立し、\ascii{OP}の計算とその\ascii{Tensor}の評価の計算環境をカプセル化します。

\end{content}

\section{リソース管理}

\begin{content}

\code{Session}のライフサイクル中に、計算グラフの計算要件に応じて、変数、キュー、リーダーなどのシステムリソースが必要に応じて割り当てられます。

\subsection{セッションのクローズ}

計算が完了したら、管理されているシステムリソースを安全に解放するために、\code{Session}が安全にクローズされていることを確認する必要があります。

\begin{leftbar}
\begin{python}
sess = tf.Session()
sess.run(targets)
sess.close()
\end{python}
\end{leftbar}

\subsection{コンテキストマネージャー}

一般的に、\code{Session}の作成にはコンテキストマネージャーを使用することが多く、計算完了後に\code{Session}が自動的にクローズされ、リソースが安全に解放されることを保証します。

\begin{leftbar}
\begin{python}
with tf.Session() as sess:
  sess.run(targets)
\end{python}
\end{leftbar}

\subsection{グラフインスタンス}

1つの\code{Session}インスタンスは1つのグラフインスタンスのみを実行できますが、1つのグラフインスタンスは複数の\code{Session}インスタンスで実行できます。同じ\code{Session}で別のグラフインスタンスを実行しようとする場合は、まず\code{Session}をクローズ（破棄する必要はありません）してから、新しいグラフの計算プロセスを開始する必要があります。

\code{Session}インスタンスは1つのグラフインスタンスのみを実行できますが、\code{Session}はスレッドセーフなクラスであり、そのグラフインスタンス上の異なるサブグラフを並行して実行できます。例えば、典型的な機械学習トレーニングモデルでは、同じ\code{Session}インスタンスを使用して、入力サブグラフ、トレーニングサブグラフ、および\ascii{Checkpoint}サブグラフを並行して実行できます。

\subsubsection{参照カウンター}

効率を高め、計算グラフの頻繁な作成と破棄を避けるために、実装上の最適化技術が存在します。グラフインスタンス内に\code{Session}の参照カウンターを維持し、\code{Session}の数が0になった場合にのみ、実際にグラフインスタンスを破棄します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.7\textwidth]{figures/tf-graph-session-relation.png}
\caption{最適化技術：セッションインスタンスの参照カウンター}
 \label{fig:tf-graph-session-relation}
\end{figure}

\subsubsection{データ構造}

ここでは、\code{TF\_Graph}の\code{Session}参照カウンター技術に関する重要なフィールドを抜粋しています。\code{TF\_Graph}構造体は\ascii{C API}のヘッダーファイルで定義されています。

\begin{leftbar}
\begin{c++}
struct TF_Graph {
  TF_Graph();

  tensorflow::mutex mu;
  tensorflow::Graph graph GUARDED_BY(mu);

  // TF\_Graph may only and must be deleted when
  // num\_sessions == 0 and delete\_requested == true

  // num\_sessions incremented by TF\_NewSession, 
  // and decremented by TF\_DeleteSession.
  int num_sessions GUARDED_BY(mu);
  bool delete_requested GUARDED_BY(mu);
};
\end{c++}
\end{leftbar}

同様に、\code{TF\_Session}は\code{<tensorflow::Sesssion, TF\_Graph>}のペアを保持しており、これらは1対1の関係です。\code{tensorflow::Sesssion}は\ascii{C++}クライアント側のセッションインスタンスです。

\begin{leftbar}
\begin{c++}
struct TF_Session {
  TF_Session(tensorflow::Session* s, TF_Graph* g)
      : session(s), graph(g), last_num_graph_nodes(0) {}
  tensorflow::Session* session;
  TF_Graph* graph;
  tensorflow::mutex mu;
  int last_num_graph_nodes;
};
\end{c++}
\end{leftbar}

\subsubsection{セッションの作成}

\begin{leftbar}
\begin{c++}
TF_Session* TF_NewSession(TF_Graph* graph, const TF_SessionOptions* opt,
                          TF_Status* status) {
  Session* session;
  status->status = NewSession(opt->options, &session);
  if (status->status.ok()) {
    if (graph != nullptr) {
      mutex_lock l(graph->mu);
      graph->num_sessions += 1;
    }
    return new TF_Session(session, graph);
  } else {
    DCHECK_EQ(nullptr, session);
    return nullptr;
  }
}
\end{c++}
\end{leftbar}

\subsubsection{セッションの破棄}

\begin{leftbar}
\begin{c++}
void TF_DeleteSession(TF_Session* s, TF_Status* status) {
  status->status = Status::OK();
  TF_Graph* const graph = s->graph;
  if (graph != nullptr) {
    graph->mu.lock();
    graph->num_sessions -= 1;
    const bool del = graph->delete_requested && graph->num_sessions == 0;
    graph->mu.unlock();
    if (del) delete graph;
  }
  delete s->session;
  delete s;
}
\end{c++}
\end{leftbar}

\section{デフォルトセッション}

\begin{content}

\ascii{Session.as\_default()}を呼び出すことで、その\code{Session}をデフォルトの\code{Session}として設定し、同時にコンテキストマネージャーを返します。デフォルトの\code{Session}のコンテキスト内で、\ascii{OP}の演算や\ascii{Tensor}の評価を直接実行できます。

\begin{leftbar}
\begin{python}
hello = tf.constant('hello, world')

sess = tf.Session()  
with sess.as_default():
  print(hello.eval())
sess.close()
\end{python}
\end{leftbar}

ただし、\code{Session.as\_default()}は自動的に\code{Session}をクローズしないため、ユーザーが明示的に\code{Session.close}メソッドを呼び出す必要があります。

\subsection{テンソルの評価}

上記のコード例では、\code{hello.eval()}は\code{tf.get\_default\_session().run(hello)}と同等です。\code{Tensor.eval}は以下のコードで実装されています。

\begin{leftbar}
\begin{python}
class Tensor(_TensorLike):
  def eval(self, feed_dict=None, session=None):
    if session is None:
      session = get_default_session()
    return session.run(tensors, feed_dict)
\end{python}
\end{leftbar}

\subsection{OP演算}

同様に、ユーザーが明示的に\code{Session}を提供しない場合、\code{Operation.run}は自動的にデフォルトの\code{Session}インスタンスを取得し、現在の\ascii{OP}の依存関係に従って、特定のトポロジカル順序でその計算サブグラフを実行します。

\begin{leftbar}
\begin{python}
class Operation(object):
  def run(self, feed_dict=None, session=None):
    if session is None:
      session = tf.get_default_session()
    session.run(self, feed_dict)
\end{python}
\end{leftbar}

\subsection{スレッド関連}

デフォルトセッションは現在のスレッドでのみ有効であり、現在のスレッドでSessionの呼び出しスタックを追跡できるようにします。新しいスレッドでデフォルトセッションを使用する場合は、スレッド関数内で\code{as\_default}を呼び出して\code{Session}をデフォルトセッションとして設定する必要があります。

実際、\ascii{TensorFlow}ランタイムは\code{Session}のローカルスレッドスタックを維持し、デフォルトの\code{Session}の自動管理を実装しています。

\begin{leftbar}
\begin{python}
_default_session_stack = _DefaultStack()

def get_default_session(session):
  return _default_session_stack.get_default(session)
\end{python}
\end{leftbar}

ここで、\code{\_DefaultStack}はスタックのデータ構造を表します。

\begin{leftbar}
\begin{python}
class _DefaultStack(threading.local):
  def __init__(self):
    super(_DefaultStack, self).__init__()
    self.stack = []

  def get_default(self):
    return self.stack[-1] if len(self.stack) >= 1 else None

  @contextlib.contextmanager
  def get_controller(self, default):
    try:
      self.stack.append(default)
      yield default
    finally:
      self.stack.remove(default)
\end{python}
\end{leftbar}

\end{content}

\section{セッションタイプ}

\begin{content}

一般的に、2つの基本的なセッションタイプが存在します：\code{Session}と\code{InteractiveSession}です。後者は対話型環境でよく使用され、構築時に自身をデフォルトとして設定し、デフォルトセッションの管理プロセスを簡素化します。

さらに、両者はランタイム構成にも違いがあります。例えば、\code{InteractiveSession}は\code{GPUOptions.allow\_growth}を\code{True}に設定し、実験環境でGPUのストレージリソース全体を独占することを避けます。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.7\textwidth]{figures/py-session-hierarchy.png}
\caption{Session：クラス階層構造}
 \label{fig:py-session-hierarchy}
\end{figure}

\subsection{Session}

\code{Session}は\code{BaseSession}を継承し、デフォルトグラフとデフォルトセッションのコンテキストマネージャー機能を追加し、システムリソースの安全な解放を保証します。

一般的に、\code{with}文を使用してセッションのコンテキストマネージャーに入り、自動的にデフォルトグラフとデフォルトセッションのコンテキストを切り替えます。\code{with}文を抜けると、デフォルトグラフとデフォルトセッションのコンテキストが自動的にクローズされ、セッションも自動的にクローズされます。

\begin{leftbar}
\begin{python}
class Session(BaseSession):
  def __init__(self, target='', graph=None, config=None):
    super(Session, self).__init__(target, graph, config=config)
    self._default_graph_context_manager = None
    self._default_session_context_manager = None

  def __enter__(self):
    self._default_graph_context_manager = self.graph.as_default()
    self._default_session_context_manager = self.as_default()

    self._default_graph_context_manager.__enter__()
    return self._default_session_context_manager.__enter__()

  def __exit__(self, exec_type, exec_value, exec_tb):
    self._default_session_context_manager.__exit__(
        exec_type, exec_value, exec_tb)
    self._default_graph_context_manager.__exit__(
        exec_type, exec_value, exec_tb)

    self._default_session_context_manager = None
    self._default_graph_context_manager = None

    self.close()
\end{python}
\end{leftbar}

\subsection{InteractiveSession}

\code{Session}とは異なり、\code{InteractiveSession}は構築時に自身をデフォルトとして設定し、デフォルトグラフとデフォルトセッションの自動切り替えを実装します。対照的に、\code{Session}はこの機能を実現するために\code{with}文に頼る必要があります。対話型環境では、\code{InteractiveSession}はユーザーのデフォルトグラフとデフォルトセッションの管理プロセスを簡素化します。

同様に、\code{InteractiveSession}は計算完了後に明示的にクローズする必要があり、占有しているシステムリソースを安全に解放します。

\begin{leftbar}
\begin{python}
class InteractiveSession(BaseSession):
  def __init__(self, target='', graph=None, config=None):
    super(InteractiveSession, self).__init__(target, graph, config)

    self._default_session_context_manager = self.as_default()
    self._default_session_context_manager.__enter__()

    self._default_graph_context_manager = graph.as_default()
    self._default_graph_context_manager.__enter__()

  def close(self):
    super(InteractiveSession, self).close()
    self._default_graph.__exit__(None, None, None)
    self._default_session.__exit__(None, None, None)
\end{python}
\end{leftbar}

\subsection{BaseSession}

\code{BaseSession}は両者の基本クラスであり、主にセッションの作成、クローズ、実行、破棄などのライフサイクル管理操作を実装します。バックエンドの計算エンジンと接続し、フロントエンドとバックエンドの計算の相互作用を実現します。

\subsubsection{セッションの作成}

\ascii{C API}のインターフェースを呼び出すことで、\code{self.\_session}はバックエンドの計算エンジンのセッションハンドルを直接保持し、後の計算グラフの実行、セッションのクローズなどの操作はすべてこのハンドルを識別子として使用します。

\begin{leftbar}
\begin{python}
class BaseSession(SessionInterface):
  def __init__(self, target='', graph=None, config=None):
    # ignore implements...
    with errors.raise_exception_on_not_ok_status() as status:
      self._session = 
        tf_session.TF_NewDeprecatedSession(opts, status)
\end{python}
\end{leftbar}

\subsubsection{計算グラフの実行}

\code{run}インターフェースを呼び出すことで、計算グラフの1回の計算を実現します。まず\code{tf\_session.TF\_ExtendGraph}を通じてグラフをバックエンドの計算エンジンに登録し、その後\code{tf\_session.TF\_Run}を呼び出して計算グラフの実行を開始します。

\begin{leftbar}
\begin{python}
class BaseSession(SessionInterface):
  def run(self, 
    fetches, feed_dict=None, options=None, run_metadata=None):
    self._extend_graph()
    with errors.raise_exception_on_not_ok_status() as status:
      return tf_session.TF_Run(session, 
        options, feed_dict, fetch_list, 
        target_list, status, run_metadata)
  
  def _extend_graph(self):
    with errors.raise_exception_on_not_ok_status() as status:
      tf_session.TF_ExtendGraph(self._session,
        graph_def.SerializeToString(), status)  
\end{python}
\end{leftbar}

\subsubsection{セッションのクローズ}

\begin{leftbar}
\begin{python}
class BaseSession(SessionInterface):
  def close(self):
    with errors.raise_exception_on_not_ok_status() as status:
      tf_session.TF_CloseDeprecatedSession(self._session, status)
\end{python}
\end{leftbar}

\subsubsection{セッションの破棄}

\begin{leftbar}
\begin{python}
class BaseSession(SessionInterface):
  def __del__(self):
    try:
      status = tf_session.TF_NewStatus()
      tf_session.TF_DeleteDeprecatedSession(self._session, status)
    finally:
      tf_session.TF_DeleteStatus(status)
\end{python}
\end{leftbar}

\end{content}
