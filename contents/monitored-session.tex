\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{MonitoredSession} 
\label{ch:monitored-session}

\begin{content}

単純なモデルを訓練する場合、モデルが収束するまで\code{train\_op}を数回実行し、最終的に訓練パラメータを\ascii{Checkpoint}として永続化することで、訓練モデルを保存できます。小規模な学習モデルの場合、このプロセスは最大で数時間しかかかりません。

しかし、大規模な学習モデルの場合、数日かかる可能性があります。また、複数のレプリカ\ascii{(replica)}を使用する必要がある場合もあり、より堅牢な訓練プロセスがモデルの訓練をサポートする必要があります。したがって、以下の3つの基本的な問題を解決する必要があります：

\begin{enum}
  \eitem{訓練プロセスが異常終了した場合、またはプログラムがクラッシュした場合に、適切に例外を処理できること。}
  \eitem{異常終了またはプログラムクラッシュ後に、訓練プロセスを復元できること。} 
  \eitem{\ascii{TensorBoard}を使用して訓練プロセス全体を監視できること。}   
\end{enum}

訓練が異常終了またはプログラムがクラッシュした後に訓練プロセスを復元できるようにするには、定期的に\ascii{Checkpoint}を実施する必要があります。訓練プロセスが再起動された後、最新の\ascii{Checkpoint}ファイルを見つけることで、訓練プロセスを復元できます。

\ascii{TensorBoard}を使用して訓練プロセスを監視できるようにするには、定期的に\ascii{Summary}の\ascii{OP}を実行し、結果をイベントファイルに追加します。\ascii{TensorBoard}はイベントファイルのデータを監視および解析し、計算グラフの構造を含む訓練プロセス全体を可視化できます。

\end{content}

\section{MonitoredSessionの導入}

\begin{content}

\code{tf.train.MonitoredSession}は、\code{Hook}をカスタマイズして\code{Session}のライフサイクル全体を監視できます。内蔵の\code{Coordinator}オブジェクトを使用して、実行中のすべてのスレッドを同時に停止し、例外を監視、報告、処理します。\code{AbortedError}または\code{UnavailableError}例外が発生した場合、\code{Session}を再起動できます。

\subsection{使用方法}

一般的に、まず\code{ChiefSessionCreator}を使用して\code{Session}インスタンスを作成し、3つの基本的な\code{tf.train.SessionRunHook}を登録します：

\begin{enum}
  \eitem{\code{CheckpointSaverHook}：定期的に\ascii{Checkpoint}を行います。}
  \eitem{\code{SummarySaverHook}：定期的に\ascii{Summary}を実行します。} 
  \eitem{\code{StepCounterHook}：定期的に1秒あたりの実行\ascii{Step}数を統計します。}   
\end{enum}

例外を安全に処理し、\code{MonitoredSession}を閉じるために、通常は\code{with}コンテキストマネージャを使用します。

\begin{leftbar}
\begin{python}
session_creator = tf.train.ChiefSessionCreator(
  checkpoint_dir=checkpoint_dir,
  master=master,
  config=config)

hooks = [
  tf.train.CheckpointSaverHook(
    checkpoint_dir=checkpoint_dir,
    save_secs=save_checkpoint_secs),
  tf.train.SummarySaverHook(
    save_secs=save_summaries_secs,
    output_dir=checkpoint_dir),
  tf.train.StepCounterHook(
    output_dir=checkpoint_dir, 
    every_n_steps=log_step_count_steps)
]

with tf.train.MonitoredSession(
  session_creator=session_creator,
  hooks=hooks) as sess:
  if not sess.should_stop():
    sess.run(train_op)
\end{python}
\end{leftbar}

\subsection{ファクトリーの使用}

\code{MonitoredTrainingSession}のファクトリーメソッドを使用すると、\code{MonitoredSession}の作成プロセスを簡略化できます。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.4\textwidth]{figures/py-train-monitored-training-session.png}
\caption{MonitoredTrainingSession：ファクトリーメソッド}
 \label{fig:py-train-monitored-training-session}
\end{figure}

\begin{leftbar}
\begin{python}
with MonitoredTrainingSession(
  master=master,
  is_chief=is_chief,
  checkpoint_dir=checkpoint_dir
  config=config) as sess:
  if not sess.should_stop():
    sess.run(train_op)
\end{python}
\end{leftbar}

\subsection{デコレータ}

複合機能の\code{MonitoredSession}を得るために、サブ機能を完了する\code{WrappedSession}を組み合わせて組み立てることができます。

\begin{enum}
  \eitem{\code{RecoverableSession}：\code{AbortedError}または\code{UnavailableError}例外が発生した場合、\code{Session}を復元および再構築できます。}
  \eitem{\code{CoordinatedSession}：内蔵の\code{Coordinator}オブジェクトを使用して、実行中のすべてのスレッドを同時に停止し、例外を監視、報告、処理します。} 
  \eitem{\code{HookedSession}：\code{Hook}をカスタマイズして、\code{Session}のライフサイクル全体を監視できます。}   
\end{enum}

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-monitored-session-decorator.png}
\caption{MonitoredSession：デコレータ}
 \label{fig:py-train-monitored-session-decorator}
\end{figure}

最終的に、3つの特性を組み合わせて\code{MonitoredSession}を構築できます（疑似コード実装、詳細は\code{MonitoredSession}の具体的な実装を参照してください）。

\begin{leftbar}
\begin{python}
MonitoredSession(
  RecoverableSession(
    CoordinatedSession(
      HookedSession(
        tf.Session(target, config)))))
\end{python}
\end{leftbar}

\end{content}

\section{ライフサイクル}

\begin{content}

\code{MonitoredSession}は\code{Session}のライフサイクル特性を持っています（ただし、\ascii{IS-A}関係ではなく、\ascii{Like-A}関係です。これは典型的なダック・プログラミングスタイルです）。

ライフサイクルプロセスでは、\code{SessionRunHook}のコールバックフックが挿入され、\code{MonitoredSession}のライフサイクルプロセスを監視します。

\subsection{初期化}

初期化段階で、\code{MonitoredSession}は主に以下のプロセスを完了します：

\begin{enum}
  \eitem{すべてのコールバックフックの\code{begin}メソッドを実行します。}
  \eitem{\code{scaffold.finalize()}を呼び出して計算グラフを凍結します。} 
  \eitem{セッションの作成：\code{SessionCreator}多態性を使用して\code{Session}を作成します。}   
  \eitem{すべてのコールバックフックの\code{after\_create\_session}メソッドを実行します。}
\end{enum}

\code{SessionCreator}多態性を使用してセッションを作成するプロセスには、2つのタイプがあります。

\begin{enum}
  \eitem{\code{ChiefSessionCreator}：\code{SessionManager.prepare\_session}を呼び出し、最新の\ascii{Checkpoing}からモデルを復元するか、\code{init\_op}を実行してモデルを初期化します。その後、すべての\code{QueueRunner}インスタンスを開始します。}
  \eitem{\code{WorkerSessionCreator}：\code{SessionManager.wait\_for\_session}を呼び出し、\code{Chief}がモデルの初期化を完了するのを待ちます。} 
\end{enum}

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-monitored-session-initialization.png}
\caption{MonitoredSession：初期化}
 \label{fig:py-train-monitored-session-initialization}
\end{figure}

\subsection{実行}

実行段階では、\code{Session.run}の実行前後にそれぞれフックの\code{before\_run}と\code{after\_run}メソッドを呼び出します。実行中に\code{AbortedError}または\code{UnavailableError}例外が発生した場合、セッションサービスを再起動します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-monitored-session-execution.png}
\caption{MonitoredSession：実行}
 \label{fig:py-train-monitored-session-execution}
\end{figure}

\subsection{終了}

訓練プロセスが終了したら、\code{close}メソッドを呼び出して\code{MonitoredSession}を閉じ、システムの計算リソースを解放します。

この時、フックの\code{end}メソッドが呼び出され、\code{Coordinator.request\_stop}メソッドを呼び出してすべての\code{QueueRunner}インスタンスを停止します。最後に、\code{tf.Session.close}メソッドを呼び出してシステムリソースを解放します。

また、\code{OutOfRangeError}例外が発生した場合、\code{MonitoredSession}は訓練プロセスが正常に終了したと見なし、その例外を無視します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-monitored-session-close.png}
\caption{MonitoredSession：終了}
 \label{fig:py-train-monitored-session-close}
\end{figure}

\end{content}

\section{モデル初期化}

\begin{content}

\code{MonitoredSession}は初期化時に\code{SessionCreator}を使用してセッションの作成とモデルの初期化を完了します。

一般的に、分散環境では2種類の\ascii{Worker}が存在します：

\begin{enum}
  \eitem{\ascii{Chief}：モデルの初期化を担当します。}
  \eitem{\ascii{Non-Chief}：\ascii{Chief}がモデルの初期化を完了するのを待ちます。} 
\end{enum}

両者は、単純な調整プロトコルを通じてモデルの初期化を共同で完了します。

\subsection{調整プロトコル}

\ascii{Chief}の場合、\ascii{Checkpoint}ファイルからモデルを復元しようとします。成功しなかった場合、\code{init\_op}を実行して新しくモデルを初期化します。その初期化アルゴリズムは、形式的に次のように記述できます：

\begin{leftbar}
\begin{python}
def prepare_session(master, init_op, saver, ckp_dir):
  if is_chief():
    sess = tf.Session(master)
    sess.run(init_op) if not saver.restore(sess, ckp_dir)
\end{python}
\end{leftbar}

\ascii{Non-Chief}の場合、定期的に\ascii{ready\_op}を実行して、\ascii{Chief}がモデルの初期化を完了したかどうかを確認します。

\begin{leftbar}
\begin{python}
def wait_for_session(master, ready_op, recovery_wait_secs):
  while True:
    sess = tf.Session(master)
    if sess.run(ready_op):
      return sess
    else:
      sess.close()
      time.sleep(recovery_wait_secs)   
\end{python}
\end{leftbar}

\subsection{SessionManager}

実際、上記のアルゴリズムは主に\code{SessionManager}によって実装されています。これは主に\ascii{Checkpoint}ファイルからモデルを復元するか、直接\code{init\_op}を実行してモデルを初期化し、最終的に動作可能な\code{Session}インスタンスを作成します。

\begin{enum}
  \eitem{\ascii{Chief}の場合、\code{prepare\_session}メソッドを呼び出してモデルの初期化を完了します。}
  \eitem{\ascii{Non-Chief}の場合、\code{wait\_for\_session}メソッドを呼び出して\ascii{Chief}がモデルの初期化を完了するのを待ちます。} 
\end{enum}

詳細については、\code{SessionManager}の具体的な実装を参照してください。

\subsection{ファクトリーの導入}

ファクトリーメソッドを使用して、\code{ChiefSessionCreator}と\code{WorkerSessionCreator}をそれぞれ使用して上記のアルゴリズムを完了します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-session-creator.png}
\caption{SessionManager}
 \label{fig:py-train-session-creator}
\end{figure}

\subsection{Scaffold}

モデルトレーニングを構築する際、変数を初期化するための\code{init\_op}が必要です。定期的に\ascii{Checkpoint}を実施するための\code{Saver}が必要です。モデルが初期化されたかどうかを確認するための\code{ready\_op}が必要です。トレーニングプロセスを可視化するためのすべての\ascii{Summary}を収集する\code{summary\_op}が必要です。

一般的に、計算グラフ内で\code{GraphKey}を使用してこれらの特殊なOPやオブジェクトを識別し、計算グラフからこれらの特殊なOPやオブジェクトを取得できるようにします。

モデルトレーニングの特殊な領域では、基本ツールライブラリ\code{Scaffold}が提供されています。これは、これらのOPやオブジェクトのデフォルト値を作成し、計算グラフのコレクションに追加し、\code{Scaffold}がこれらのOPやオブジェクトを簡単に取得できるクエリインターフェースを提供します。

\code{Scaffold.finalize}メソッドを呼び出すことで、対応するOPやオブジェクトが\code{None}の場合、デフォルトでそのタイプのインスタンスを作成します。最終的に計算グラフを凍結し、その後グラフにノードを追加することを禁止します。

\begin{leftbar}
\begin{python}
class Scaffold(object):
  def finalize(self):
    """Creates operations if needed and finalizes the graph."""
    
    # create init\_op
    if self._init_op is None:
      def default_init_op():
        return control_flow_ops.group(
            variables.global_variables_initializer(),
            resources.initialize_resources(
              resources.shared_resources()))
      self._init_op = Scaffold.get_or_default(
          'init_op',
          ops.GraphKeys.INIT_OP,
          default_init_op)

    # create ready\_op
    if self._ready_op is None:
      def default_ready_op():
        return array_ops.concat([
            variables.report_uninitialized_variables(),
            resources.report_uninitialized_resources()
        ], 0)
      self._ready_op = Scaffold.get_or_default(
          'ready_op', 
          ops.GraphKeys.READY_OP,
          default_ready_op)
    
    # create ready\_for\_local\_init\_op
    if self._ready_for_local_init_op is None:
      def default_ready_for_local_init_op():
        return variables.report_uninitialized_variables(
            variables.global_variables())
      self._ready_for_local_init_op = Scaffold.get_or_default(
          'ready_for_local_init_op',
          ops.GraphKeys.READY_FOR_LOCAL_INIT_OP,
          default_ready_for_local_init_op)
    
    # create local\_init\_op
    if self._local_init_op is None:
      def _default_local_init_op():
        return control_flow_ops.group(
            variables.local_variables_initializer(),
            lookup_ops.tables_initializer())
      self._local_init_op = Scaffold.get_or_default(
          'local_init_op',
          ops.GraphKeys.LOCAL_INIT_OP,
          _default_local_init_op)
    
    # create summary\_op
    if self._summary_op is None:
      self._summary_op = Scaffold.get_or_default(
          'summary_op',
          ops.GraphKeys.SUMMARY_OP,
          summary.merge_all)
    
    # create Saver
    if self._saver is None:
      self._saver = training_saver._get_saver_or_default()
    self._saver.build()

    ops.get_default_graph().finalize()
    return self
\end{python}
\end{leftbar}

\code{finalize}の実装から、以下のOPが完了する機能は次のとおりです：

\begin{enum}
  \eitem{\code{init\_op}：すべてのグローバル変数とグローバルリソースの初期化を完了します。}
  \eitem{\code{local\_init\_op}：すべてのローカル変数とテーブルの初期化を完了します。} 
  \eitem{\code{ready\_op}：すべてのグローバル変数とグローバルリソースが初期化されているかどうかを確認します。そうでない場合、初期化されていないグローバル変数とグローバルリソースのリストを報告します。}   
  \eitem{\code{ready\_for\_local\_init\_op}：すべてのローカル変数とテーブルが初期化されているかどうかを確認します。そうでない場合、初期化されていないローカル変数とテーブルのリストを報告します。}   
  \eitem{\code{summary\_op}：すべての\ascii{Summary}の出力を要約します。}       
\end{enum}

ここで、ローカル変数は\ascii{Checkpoint}ファイルに永続化できません。もちろん、\ascii{Checkpoint}ファイルからローカル変数の値を復元することもできません。

\subsection{初期化アルゴリズム}

上記のOPの定義を観察することで、\code{prepare\_session}モデル初期化の完全な意味を理解するのはそれほど困難ではありません。

\begin{leftbar}
\begin{python}
class SessionManager(object):
  def prepare_session(self,
                      master,
                      saver=None
                      checkpoint_filename=None
                      init_op=None,
                      init_feed_dict=None,
                      init_fn=None):
    """Creates a Session. Makes sure the model is ready."""

    def _restore_checkpoint():
      sess = session.Session(master)
      if not saver or not checkpoint_filename):
        return sess, False
      else:
        saver.restore(sess, checkpoint_filename)
        return sess, True

    def _try_run_init_op(sess):
      if init_op is not None:
        sess.run(init_op, feed_dict=init_feed_dict)
      if init_fn:
        init_fn(sess)
    
    sess, is_succ = self._restore_checkpoint()
    if not is_succ:
      _try_run_init_op(sess)
    self._try_run_local_init_op(sess)
    self._model_ready(sess)
    return sess
\end{python}
\end{leftbar}

その初期化アルゴリズムは非常にシンプルです。まず、\ascii{Checkpoint}ファイルからの復元を試みます（ここでは問題を簡略化するために、一部の実装を省略しています）。失敗した場合、\code{init\_op}と\code{init\_fn}を呼び出してグローバル変数とリソースの初期化を完了します。次に、ローカル変数とテーブルの初期化を実施できます。最後に、すべてのグローバル変数とリソースが初期化されたかどうかを検証します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-session-initialization-algo.png}
\caption{モデル初期化アルゴリズム}
 \label{fig:py-train-session-initialization-algo}
\end{figure}

\subsection{ローカル変数の初期化}

空でない\code{local\_init\_op}の場合、すべてのグローバル変数が初期化された後にのみ初期化を行うことができます（\code{\_ready\_for\_local\_init\_op}の呼び出しによって）。そうでない場合、初期化されていないグローバル変数のリストを\code{msg}フィールドに報告します。

つまり、ローカル変数の初期化はグローバル変数の初期化の後に行われ、ローカル変数は\ascii{Checkpoint}ファイルに永続化されません。

\begin{leftbar}
\begin{python}
class SessionManager(object):
  def _ready_for_local_init(self, sess):
    """Checks if the model is ready to run local_init_op.
    """
    return _ready(self._ready_for_local_init_op, sess,
                  "Model not ready for local init")

  def _try_run_local_init_op(self, sess):
    """Tries to run _local_init_op, if not None, 
       and is ready for local init.
    """
    if not self._local_init_op:
      return True, None:
    
    is_ready, msg = self._ready_for_local_init(sess)
    if is_ready:
      sess.run(self._local_init_op)
      return True, None
    else:
      return False, msg
\end{python}
\end{leftbar}

\subsection{モデルの検証}

最後に、\code{\_ready\_op}を実行して、すべてのグローバル変数とグローバルリソースが初期化されているかどうかを確認します。そうでない場合、初期化されていない変数のリストを\code{msg}フィールドに報告します。

\begin{leftbar}
\begin{python}
class SessionManager(object):
  def _model_ready(self, sess):
    """Checks if the model is ready or not.
    """
    return _ready(self._ready_op, sess, "Model not ready")
\end{python}
\end{leftbar}

ここで、\code{\_ready}関数は、対応する\code{ready\_op}を実行して、対応する変数またはリソースが初期化されているかどうかを確認するために使用されます。

\begin{leftbar}
\begin{python}
def _ready(op, sess, msg):
  """Checks if the model is ready or not, as determined by op.
  """
  if op is None:
    return True, None

  ready_value = sess.run(op)
  if (ready_value.size == 0):
    return True, None
  else:
    uninitialized_vars = ", ".join(
        [i.decode("utf-8") for i in ready_value])
    return False, "initialized vars: " + uninitialized_vars
\end{python}
\end{leftbar}

\end{content}

\section{例外安全性}

\begin{content}

一般的に、\code{with}コンテキストマネージャを使用して、\code{MonitoredSession}の例外安全性とリソースの安全な解放を実現します。

\subsection{コンテキストマネージャ}

\code{with}ステートメントを終了すると、すべての\code{QueueRunner}インスタンスの実行が停止され、\code{tf.Session}の安全な終了が実装されます。

\begin{leftbar}
\begin{python}
class _MonitoredSession(object):
  def __exit__(self, exception_type, exception_value, traceback):
    if exception_type in [errors.OutOfRangeError, StopIteration]:
      exception_type = None
    self._close_internal(exception_type)
    return exception_type is None
  
  def _close_internal(self, exception_type=None):
    try:
      if not exception_type:
        for h in self._hooks:
          h.end(self.tf_sess)
    finally:
      try:
        self._sess.close()
      finally:
        self._sess = None
        self.tf_sess = None
        self.coord = None  
\end{python}
\end{leftbar}

特に、\code{OutOfRangeError}または\code{StopIteration}が発生した場合、正常終了と見なされ、その例外は無視されます。他のタイプの例外がスローされた場合、\code{end}コールバックフックは呼び出されません。

\subsection{QueueRunnerの停止}

さらに、\code{self.\_sess.close()}を実行すると、最終的に\code{\_CoordinatedSession}の\code{close}メソッドが呼び出されます。\code{coord.request\_stop}を呼び出してすべての\code{QueueRunner}インスタンスに停止を通知し、\code{coord.join}メソッドを呼び出してすべての\code{QueueRunner}インスタンスの実行が完了するのを待ちます。

\begin{leftbar}
\begin{python}
class _CoordinatedSession(_WrappedSession):
  def close(self):
    self._coord.request_stop()
    try:
      self._coord.join()
    finally:
      try:
        _WrappedSession.close(self)
      except Exception:
        pass
\end{python}
\end{leftbar}

\end{content}

\section{コールバックフック}

\begin{content}

\code{SessionRunHook}をカスタマイズすることで、\code{MonitorSession}のライフサイクルプロセスの監視と管理を実装できます。

\begin{leftbar}
\begin{python}
class SessionRunHook(object):
  def begin(self):
    pass

  def after_create_session(self, session, coord):
    pass

  def before_run(self, run_context):
    return None

  def after_run(self, run_context, run_values):
    pass

  def end(self, session):
    pass
\end{python}
\end{leftbar}

最も一般的な\code{Hook}には以下が含まれます：

\begin{enum}
  \eitem{\code{CheckpointSaverHook}：定期的に\ascii{Checkpoint}を実施します。}
  \eitem{\code{SummarySaverHook}：定期的に\ascii{Summary}を実行します。} 
  \eitem{\code{StepCounterHook}：定期的に1秒あたりの実行\ascii{Step}数を統計します。}   
\end{enum}

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-train-session-run-hook.png}
\caption{SessionRunHook}
 \label{fig:py-train-session-run-hook}
\end{figure}

\end{content}
