\chapter{コード読解} 
\label{ch:code-reading}

\begin{content}

プログラマーの日常業務において、大半の時間は\emph{コードを読む}ことに費やされ、コードを書くことではありません。しかし、コードを読むことは往々にして退屈な作業です。特に美しくない設計に遭遇すると、抵抗感はさらに強くなります。実際のところ、習慣や思考、方法を変えることで、コード読解は非常に楽しいプロセスになり得ます。

コード読解のパターン、実践、習慣について、ギリシャの作家\ascii{Diomidis Spinellis}の古典的名著：\ascii{Code Reading, The Open Source Perspective}が最も包括的です。本文では別の視点から、私のコード読解の習慣について話し、より多くの共感を得られることを期待しています。

\end{content}

\section{良い仕事をするには、まず道具を整えよ}

\begin{content}

まず、コードを読む前に、\ascii{IDE}、\ascii{UML}、マインドマップなどのツールを含む、心地よいツールボックスを用意します。私が主に使用するプログラミング言語には\ascii{C++, Scala, Java, Ruby, Python}が含まれます。私は\ascii{JetBrains}社の製品を好んで使用します。その多くの機能はプログラマーにとって非常に便利です。

次に、ショートカットキーを効率的に使用することは、良いコード読解の習慣です。これはコード読解の効率と品質を大幅に向上させます。例えば、クラス階層の表示、関数呼び出しチェーン、メソッド参照ポイントなどです。

\begin{remark}
マウスを外し、マウスへの依存を減らします。マウスがないために作業が進められなくなったときは、対応するショートカットキーを探してみましょう。日々の積み重ねにより、作業効率は必ず倍増します。
\end{remark}

\end{content}

\section{実践してこそ真の理解に至る}

\begin{content}

コード読解の一般的なアンチパターンの1つは、\ascii{Debug}を通じてコードを読むことです。著者はこのコード読解方法を推奨しません。第一に、実行時のスレッド間の切り替えにより方向性を見失いやすいからです。第二に、コールスタックを理解することは、システムの動作を理解する上で必ずしも効果的ではありません。多くの実装の詳細が含まれるため、問題の本質を発見しにくいからです。

しかし、コードを読む前にいくつかのことを必ず行う必要があります。まず、手動でプロジェクトをビルドし、テストケースを実行すること。次に、自分で数個の\ascii{Demo}を書いて体験してみることです。

まずプロジェクトを動かすことは、コードを\ascii{Debug}するためではなく、プロジェクトのビルド方法を理解し、システムの基本構造を認識し、システムの使用方法を体験するためです。

可能であれば、\ascii{ATDD}の方法を試し、システムの動作を発見・掘り下げてみましょう。このプロセスを通じて、自分を顧客と見なし、システムの動作について考えることは、システムを理解する上で最も重要な基盤となります。

\end{content}

\section{ドメインモデルの発見}

\begin{content}

コードを読むことは、各クラスや各関数が何をするかを理解するためではなく、より本質的で、より変化しにくい知識を掘り下げるためです。実際、\emph{ドメインモデル}を発見することがコード読解の最も重要な目標の1つです。なぜなら、ドメインモデルはシステムの魂だからです。コード読解を通じて、システムの本質的な知識を見つけ、自分のパターンで表現することで、初めてシステムの脈絡を真に把握できます。そうでなければ、すべては空論に過ぎません。

例えば、\tf{}の\ascii{Python}実装のクライアントコードを読む際、計算グラフのドメインモデルを整理することは、\ascii{TensorFlow}のプログラミングモデルとシステムの実行時の動作を理解する上で非常に重要です。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-graph.png}
\caption{ドメインオブジェクト：Graph}
 \label{fig:py-graph}
\end{figure}

\end{content}

\section{システムアーキテクチャの掘り下げ}

\begin{content}

コードを読むことは大海を航海するようなものです。システムアーキテクチャ図は航海図です。全体的なシステムの概念なしにコードを読むと、効果が低く、読解の質が大幅に低下します。システム思考を持ち、明確な目標を持つことで、方向を見失わないようにすることが必要です。

最優先の課題は、システムの境界を見つけ、抽象的な思考で外部システムの動作特性を考えることです。次に、システム内の各コンポーネント間の相互作用、関連関係、および責任を明確にすることが、システム全体の動作を理解する上で非常に重要です。

例えば、\ascii{TensorFlow}では、\ascii{C API}がフロントエンドとバックエンドシステムを橋渡しする役割を果たしています。\ascii{C API}の設計を理解することで、フロントエンドとバックエンドシステムの動作をほぼ推測することができます。

\begin{figure}[!h]
\centering
\includegraphics[width=0.9\textwidth]{figures/tf-architecture-simple.png}
\caption{TensorFlowシステムアーキテクチャ}
 \label{fig:tf-architecture-simple}
\end{figure}

\end{content}

\section{細部は悪魔である}

\begin{content}

細部にこだわりすぎると、コード読解の効率と質が大幅に低下します。例えば、ログ出力、特定の\ascii{Bug}を修正するためのパッチ実装、特定のバージョン分岐の互換性ソリューション、一部の極端な要求に対する無理やりなコード実装などです。

コード読解の一般的なアンチパターンの1つは「コードにコメントを付ける」ことです。これは投資対効果が極めて低い、非常にコストの高い実践です。一般的に、より優雅なシステムほどコメントは少なくなります。複雑なシステムでは、どれだけコメントを付けても無駄です。

私にはコード読解の習慣があります。コード読解のために別の\ascii{code-reading}ブランチを作成し、コードを読みながら、これらの無関係なコードを削除します。

\begin{leftbar}
\begin{scala}
$ git checkout -b code-reading
\end{scala}
\end{leftbar}

これらのノイズを削除すると、システムが想像していたほど複雑ではないことに気づくでしょう。現実には、システムの複雑さは、往々にして未成熟な設計と実装によって引き起こされる余分な複雑さです。システムへの理解が深まるにつれて、多くの細部が自然と浮かび上がり、すべての神秘のベールが取り除かれて明らかになります。

\end{content}

\section{ほどほどにする}

\begin{content}

コード読解の一般的なアンチパターンの1つは「一本道を最後まで行き、黄河に達するまで諦めない」ことです。プログラマーは皆好奇心旺盛で、常に不明確なことに興味を持ちます。例えば、メッセージはどのように送信されるのか？タスクスケジューリングの動作原理は何か？データストレージはどのように実現されているのか？このような勇気は賞賛に値しますが、コード読解時には決して奨励されるべきではありません。

もう1つの一般的なアンチパターンは「関数呼び出しスタックを追跡する」ことです。これは非常に退屈なプロセスで、しばしば思考の硬直化を引き起こします。なぜなら、あなたは常に作者の影の下に生きることになり、全く自分自身がなくなるからです。

私個人がコードを読む際、関数呼び出しスタックの深さは絶対に\ascii{3}を超えません。その後、抽象的な思考方法を使用して下層の呼び出しを考えます。なぜなら、年齢を重ねるにつれて、かつては誇りに思っていた記憶力が徐々に短所になっていくことに気づいたからです。深すぎる呼び出しスタックを追跡しようとすると、以前の読解情報が完全に記憶から消えてしまいます。

つまり、私は「深さ優先探索」よりも「幅優先探索」の読解方法を好みます。このようにして、システムに隠れて存在する「層の概念」を見つけ、システムの階層構造を整理することができます。

\end{content}

\section{その美しさを発見する}

\begin{content}

三人行えば、必ず我が師あり。コードを読む際、良い設計（実装パターン、慣用的な書き方など）を発見したら、決して見逃さないでください。さもなければ、しばらくすると、このコード読解はあなたにとって何の価値もなくなってしまいます。

良い設計を発見したとき、私はクラス図、状態機械、シーケンス図などの方法を使ってその設計を表現しようとします。潜在的な不足点を発見した場合、自分のアイデアを補足すると、さらに完璧になります。

例えば、\ascii{Hamcrest}を読んだとき、クラス図を描いてみて、それらの関係を体感し、設計の美しさを感じることも、非常に有益です。

\begin{figure}[!h]
\centering
\includegraphics[width=0.9\textwidth]{figures/hamcrest.png}
\caption{組み合わせ設計}
 \label{fig:hamcrest}
\end{figure}

\end{content}

\section{リファクタリングを試みる}

\begin{content}

これはコード読解のプロセスであるため、リファクタリングによる潜在的なリスクの問題は発生しません。複雑なロジックの場合、リファクタリングによる等価変換を通じて、より明確で直感的なものにすることができます。

巨大な関数に対して、私はしばしば抽象的なコードレベルを抽出し、その潜在的な本質的ロジックを発見しやすくします。例えば、これは\ascii{Scala}で実装された\ascii{ArrayBuffer}です。末尾に要素を追加する必要がある場合、既存の設計は次のようになっています。

\begin{leftbar}
\begin{python}
def +=(elem: A): this.type = {
  if (size + 1 > array.length) {
    var newSize: Long = array.length
    while (n > newSize)
      newSize *= 2
    newSize = math.min(newSize, Int.MaxValue).toInt
  
    val newArray = new Array[AnyRef](newSize)
    System.arraycopy(array, 0, newArray, 0, size)
    array = newArray
  }
  array(size) = elem.asInstanceOf[AnyRef]
  size += 1
  this
}
\end{python}
\end{leftbar}

このコードは読解に大きな障害をもたらします。私は迅速な関数抽出を試み、ロジックの主要部分を発見します。

\begin{leftbar}
\begin{python}
def +=(elem: A): this.type = {
  if (atCapacity)
    grow()
  addElement(elem)
}
\end{python}
\end{leftbar}

\code{atCapacity, grow, addElement}がどのように実装されているかは全く気にする必要はありません。なぜなら、私はすでにコード読解の効果を達成しているからです。

\end{content}

\section{形式化}

\begin{content}

コードを読む際、一部の人々は「フローチャート」を描く習慣があります。逆に、私はほとんど「フローチャート」を描きません。なぜなら、フローチャートはあまりにも多くの実装の詳細を反映し、アルゴリズムの本質を深く反映していないからです。

私はより「形式化」された方法で問題を記述することを好みます。それは数学的な美しさ、簡潔な表現方法、そして高度に抽象的な思考を持ち、問題の本質を掘り下げるのに非常に重要です。

例えば、\ascii{FizzBuzzWhizz}の問題について、冗長な文章による説明やフローチャートよりも、形式化された方法がより簡単で表現力豊かです。\ascii{3, 5, 7}を入力として、形式化後の記述により、問題の本質を明確に掘り下げることができます。

\begin{leftbar}
\begin{python}
r1: times(3) => Fizz || 
    times(5) => Buzz ||
    times(7) => Whizz

r2: times(3) && times(5) && times(7) => FizzBuzzWhizz ||
    times(3) && times(5) => FizzBuzz  ||
    times(3) && times(7) => FizzWhizz ||
    times(5) && times(7) => BuzzWhizz

r3: contains(3) => Fizz

rd: others => string of others

spec: r3 || r2 || r1 || rd
\end{python}
\end{leftbar}

\end{content}

\section{インスタンス化}

\begin{content}

インスタンス化は問題を認識する重要な方法の1つです。ロジックが非常に複雑な場合、単純な例がしばしば理解の突破口となります。理想的な状況では、インスタンス化を自動化されたテストケースにし、それによってシステムの動作を記述することができます。

あるアルゴリズムとその実装が非常に複雑な場合、インスタンス化を通じてアルゴリズムの動作原理を探ることもできます。これは問題自体を理解する上で非常に有益です。

\ascii{Spark}の\ascii{DAG}分割アルゴリズムを例にとります。\ascii{G}を開始ノードとして、後ろから前に\ascii{RDD}の依存関係に従って、各\ascii{Stage}の境界を順次識別します。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/spark-stage-dag.png}
\caption{Spark：Stage分割アルゴリズム}
 \label{fig:spark-stage-dag}
\end{figure}

\begin{itemize}
 \item \ascii{Stage 3}の分割
   \begin{enum}
     \eitem{\ascii{G}と\ascii{B}の間は狭い依存関係で、同じ\ascii{Stage(3)}に縮約されます。}
     \eitem{\ascii{B}と\ascii{A}の間は広い依存関係で、\ascii{A}は新しい開始\ascii{RDD}となり、このプロセスを再帰的に呼び出します。}
     \eitem{\ascii{G}と\ascii{F}の間は広い依存関係で、\ascii{F}は新しい開始\ascii{RDD}となり、このプロセスを再帰的に呼び出します。} 
   \end{enum}

 \item \ascii{Stage 1}の分割
   \begin{enum}
     \eitem{\ascii{A}には親\ascii{RDD}がないため、\ascii{Stage(1)}の分割が終了します。特別に\ascii{Stage(1)}は\ascii{RDD A}のみを含みます。}
   \end{enum}
 \item \ascii{Stage 2}の分割
   \begin{enum}
     \eitem{\ascii{RDD}間の関係がすべて狭い依存関係であるため、同じ\ascii{Stage(2)}に縮約されます。}
     \eitem{\ascii{RDD C, E}まで到達し、親\ascii{RDD}がないため、\ascii{Stage(2)}の分割が終了します。}
   \end{enum} 
\end{itemize}

最終的に、\ascii{Stage}の依存関係が形成され、順次\ascii{TaskSet}を\ascii{TaskScheduler}に提出して、スケジューリングと実行が行われます。

\end{content}

\section{楽しみは共有するもの}

\begin{content}

他の人とあなたの経験を共有することで、さらに多くのインスピレーションを得ることができるかもしれません。特に、その分野に精通している人と、所有者であればなおさら良いのですが、コミュニケーションを取ることで、予想外の驚きと収穫を得ることができます。

また、様々なチャネルを通じて他の人の経験を集め、自分の思考と組み合わせて自分なりの理解を深めることで、初めて知識を自分のものにすることができます。

コード読解は一人の世界ではありません。外に出て、コミュニティ活動に積極的に参加し、エコシステム内の主流の研究方向、技術動向、産業の発展について理解することは、ビジネスを理解する上で非常に役立ちます。

\end{content}
