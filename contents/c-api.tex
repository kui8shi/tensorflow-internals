\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{C API：分水嶺} 
\label{ch:c-api}

\begin{content}

本章では、クライアントの\ascii{Session}ライフサイクルの実装を例に、フロントエンドの\ascii{Python}とバックエンドの\cpp{}システムの実装チャネルを明らかにし、\ascii{TensorFlow}のマルチ言語プログラミングの秘密を解き明かします。

\end{content}

\section{Swig：縁の下の力持ち}

\begin{content}

フロントエンドのマルチ言語プログラミング環境とバックエンドの\cpp{}実装システムのチャネルは、\ascii{Swig}のラッパーのおかげです。\ascii{TensorFlow}は\ascii{Bazel}ビルドツールを使用し、システムのコンパイル前に\ascii{Swig}のコード生成プロセスを開始し、\code{tensorflow.i}を通じて2つの適応（\ascii{Wrapper}）ファイルを自動生成します：

\begin{enum}
  \eitem{\code{pywrap\_tensorflow\_internal.py}:  上層の\ascii{Python}呼び出しを担当；}
  \eitem{\code{pywrap\_tensorflow\_internal.cc}: 下層の\ascii{C API}呼び出しを担当。}
\end{enum}

\refig{swig}に示すように、\code{pywrap\_tensorflow\_internal.py}モジュールが初めてインポートされると、自動的に\code{\_pywrap\_tensorflow\_internal.so}動的リンクライブラリをロードします。この\code{\_pywrap\_tensorflow\_internal.so}には、\tf{}ランタイムの全シンボルが含まれています。\code{pywrap\_tensorflow\_internal.cc}の実装では、関数シンボルテーブルが静的に登録され、\ascii{Python}関数名と\ascii{C}関数名の二項関係が実現されています。実行時には、\ascii{Python}の関数名に応じて、対応する\ascii{C}関数の実装を見つけ、最終的に\ascii{Python}から\code{c\_api.c}の具体的な実装への呼び出し関係を実現します。

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{figures/swig.png}
\caption{Swigコードジェネレーター}
 \label{fig:swig}
\end{figure}

ここで、\ascii{Bazel}の生成ルールは\code{//tensorflow/python:pywrap\_tensorflow\_internal}で定義されており、以下のコードのようになっています。

\begin{leftbar}
\begin{python}
tf_py_wrap_cc(
    name = "pywrap_tensorflow_internal",
    srcs = ["tensorflow.i"],
    swig_includes = [
        "client/device_lib.i",
        "client/events_writer.i",
        "client/tf_session.i",
        "client/tf_sessionrun_wrapper.i",
        "framework/cpp_shape_inference.i",
        "framework/python_op_gen.i",
        "grappler/cost_analyzer.i",
        "grappler/model_analyzer.i",
        "grappler/tf_optimizer.i",
        "lib/core/py_func.i",
        "lib/core/strings.i",
        "lib/io/file_io.i",
        "lib/io/py_record_reader.i",
        "lib/io/py_record_writer.i",
        "platform/base.i",
        "pywrap_tfe.i",
        "training/quantize_training.i",
        "training/server_lib.i",
        "util/kernel_registry.i",
        "util/port.i",
        "util/py_checkpoint_reader.i",
        "util/stat_summarizer.i",
        "util/tfprof.i",
        "util/transform_graph.i",
    ]
)
\end{python}
\end{leftbar}

以下では、クライアントの\ascii{Session}ライフサイクルの実装を例に、フロントエンドの\ascii{Python}とバックエンドの\cpp{}システムの実装チャネルを明らかにします。

\end{content}

\section{セッション制御}

\begin{content}

厳密には、\ascii{C API}は\ascii{Client}と\ascii{Master}の境界線ではありません。\refig{tf-client-session}に示すように、\ascii{Client}には一部\cpp{}実装、つまり\code{tensorflow::Session}が存在します。ここで、\code{tf.Session}インスタンスは\code{tensorflow::Session}インスタンスのハンドルを直接保持しています。実際の実行時環境では、\code{tensorflow::Session}には複数の実装が存在する可能性があります。例えば、\code{DirectSession}は\emph{ローカルモード}のセッション制御を担当します。一方、\code{GrpcSession}は\ascii{gRPC}プロトコルに基づく\emph{分散モード}のセッション制御を担当します。一般に、ユーザーは\code{tensorflow::Session}ではなく、\code{tf.Session}を使用してプログラミングを行います。

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.9\textwidth]{figures/tf-client-session.png}
\caption{クライアント：tensorflow::Sessionインスタンス作成プロセス}
 \label{fig:tf-client-session}
\end{figure}

\end{content}

\section{セッションライフサイクル}

\begin{content}

セッションのライフサイクルには、セッションの作成、計算グラフの作成、計算グラフの拡張、計算グラフの実行、セッションの終了、セッションの破棄という基本的なプロセスが含まれます。フロントエンドの\ascii{Python}とバックエンドの\cpp{}では、2つの互換性のあるインターフェース実装として現れます。

\subsection{Pythonフロントエンド}

\refig{py-session-lifecycle}に示すように、\ascii{Python}フロントエンドでは、\code{Session}のライフサイクルは主に以下の点に現れます：

\begin{enum}
  \eitem{\code{Session(target)}の作成；}
  \eitem{\code{Session.run(fetches, feed\_dict)}の反復実行；}
    \begin{enum}
      \eitem{\code{Session.\_extend\_graph(graph)}；}
      \eitem{\code{Session.TF\_Run(feeds, fetches, targets)}；}
    \end{enum}
  \eitem{\code{Session}の終了；}
  \eitem{\code{Session}の破棄；}
\end{enum}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figures/py-session-lifecycle.png}
\caption{Python: Sessionライフサイクル}
 \label{fig:py-session-lifecycle}
\end{figure}

例えば、ここではローカルモードの\code{Session}インスタンスを作成し、\code{mnist}のトレーニングプロセスを開始します。

\begin{leftbar}
\begin{python}
sess = tf.Session()
for _ in range(1000):
  batch_xs, batch_ys = mnist.train.next_batch(100)
  sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})
sess.close()
\end{python}
\end{leftbar}

\subsection{C++バックエンド}

同様に、\cpp{}バックエンドでは、\code{Session}のライフサイクルは主に以下の点に現れます：

\begin{enum}
  \eitem{\code{target}に基づく多態的な\code{Session}の作成；}
  \eitem{\code{Session.Create(graph)}：一度だけ；}
  \eitem{\code{Session.Extend(graph)}：ゼロ回または複数回；}
  \eitem{\code{Session.Run(inputs, outputs, targets)}の反復実行；}
  \eitem{\code{Session.Close}によるセッションの終了；}
  \eitem{\code{Session}オブジェクトの破棄。}
\end{enum}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/cc-session-lifecycle.png}
\caption{C++: Sessionライフサイクル}
 \label{fig:cc-session-lifecycle}
\end{figure}

例えば、ここではローカルモードの\code{DirectSession}インスタンスを作成し、計算グラフの実行プロセスを開始します。

\begin{leftbar}
\begin{c++}
// create/load graph ...
tensorflow::GraphDef graph;

// local runtime, target is ""
tensorflow::SessionOptions options;

// create Session
std::unique_ptr<tensorflow::Session> 
sess(tensorflow::NewSession(options));

// create graph at initialization.
tensorflow::Status s = sess->Create(graph);
if (!s.ok()) { ... }

// run step
std::vector<tensorflow::Tensor> outputs;
s = session->Run(
  {},               // inputs is empty
  {"output:0"},     // outputs names
  {"update_state"}, // target names
  &outputs);        // output tensors
if (!s.ok()) { ... }

// close
session->Close();
\end{c++}
\end{leftbar}

\end{content}

\section{セッションの作成}

\begin{content}

以下では、Sessionの作成の詳細なプロセスを説明します。\ascii{Python}フロントエンドを起点とし、\ascii{Swig}によって自動生成された\ascii{Python-C++}ラッパーを通じて、\ascii{Python}から\ascii{TensorFlow}の\ascii{C API}への呼び出しを実現します。ここで、\ascii{C API}はフロントエンドシステムとバックエンドシステムの分水嶺です。

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{figures/py-create-session.png}
\caption{セッションの作成}
 \label{fig:py-create-session}
\end{figure}

\subsection{プログラミングインターフェース}

\ascii{Client}が計算グラフの実行プロセスを開始する際、まず\code{Session}インスタンスを作成し、その後親クラス\code{BaseSession}のコンストラクタを呼び出します。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
class Session(BaseSession):
  def __init__(self, target='', graph=None, config=None):
    super(Session, self).__init__(target, graph, config=config)
    self._default_graph_context_manager = None
    self._default_session_context_manager = None
\end{python}
\end{leftbar}

\code{BaseSession}のコンストラクタ内で、\code{pywrap\_tensorflow}モジュール内の関数を呼び出します。ここで、\code{TF\_NewDeprecatedSession}は古い実装で、既に非推奨となっています。新しい\ascii{API}では、グラフインスタンスを直接バックエンドの\ascii{C++}に渡すことで、フロントエンドとバックエンドのグラフインスタンスのシリアライズのオーバーヘッドを避けています。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
from tensorflow.python import pywrap_tensorflow as tf_session

class BaseSession(SessionInterface):
  def __init__(self, target='', graph=None, config=None):
    # デフォルトグラフ
    if graph is None:
      self._graph = ops.get_default_graph()
    else:
      self._graph = graph

    # tensorflow::Sessionへのハンドル
    self._session = None
    opts = tf_session.TF_NewSessionOptions(target=self._target, 
                                           config=config)
    try:
      with errors.raise_exception_on_not_ok_status() as status:
        if self._created_with_new_api:
          self._session = tf_session.TF_NewSession(
              self._graph._c_graph, opts, status)
        else:
          self._session = tf_session.TF_NewDeprecatedSession(opts, status)
    finally:
      tf_session.TF_DeleteSessionOptions(opts)
\end{python}
\end{leftbar}

\refig{tf-graph-inst}に示すように、\code{ScopedTFGraph}は\code{TF\_Graph}のラッパーで、\ascii{C++}の\ascii{RAII}に似た作業メカニズムを完了します。一方、\code{TF\_Graph}は\code{tensorflow::Graph}インスタンスを保持しています。ここで、\code{self.\_graph.\_c\_graph}は\code{TF\_Graph}インスタンスを返し、後者は\ascii{C API}によって作成されたグラフインスタンスです。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/framework/ops.py}]
class Graph(object):
  def __init__(self):
    if _USE_C_API:
      self._scoped_c_graph = c_api_util.ScopedTFGraph()
    else:
      self._scoped_c_graph = None

  def _c_graph(self):
    if self._scoped_c_graph:
      return self._scoped_c_graph.graph
    return None
\end{python}
\end{leftbar}

\begin{leftbar}
\begin{python}[caption={tensorflow/python/framework/c\_api\_util.py}]
class ScopedTFGraph(object):
  def __init__(self):
    self.graph = c_api.TF_NewGraph()

  def __del__(self):
    if c_api.TF_DeleteGraph is not None:
      c_api.TF_DeleteGraph(self.graph)
\end{python}
\end{leftbar}

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{figures/tf-graph-inst.png}
\caption{フロントエンドとバックエンド：グラフインスタンスの受け渡し}
 \label{fig:tf-graph-inst}
\end{figure}

\subsubsection{Pythonラッパー}

\code{pywrap\_tensorflow}モジュールでは、\code{\_pywrap\_tensorflow\_internal}を通じて転送することで、\ascii{Python}から動的リンクライブラリ\code{\_pywrap\_tensorflow\_internal.so}への関数呼び出しを実現しています。

\begin{leftbar}
\begin{python}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.py}]
def TF_NewDeprecatedSession(opts, status):
  return _pywrap_tensorflow_internal.TF_NewDeprecatedSession(opts, status)

def TF_NewSession(graph, opts, status):
  return _pywrap_tensorflow_internal.TF_NewSession(graph, opts, status)
\end{python}
\end{leftbar}

\subsubsection{C++ラッパー}

\code{pywrap\_tensorflow\_internal.cc}の具体的な実装では、関数呼び出しのシンボルテーブルを静的に登録し、\ascii{Python}の関数名から\cpp{}関数の実装への具体的なマッピングを実現しています。

\begin{leftbar}
\begin{c++}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.cc}]
static PyMethodDef SwigMethods[] = {
  // ...
  { (char *)"TF_NewDeprecatedSession", 
    _wrap_TF_NewDeprecatedSession, METH_VARARGS, NULL},

  { (char *)"TF_NewSession", 
    _wrap_TF_NewSession, METH_VARARGS, NULL},
};
\end{c++}
\end{leftbar}

最終的に、\code{\_wrap\_TF\_NewSession/\_wrap\_TF\_NewDeprecatedSession}は、それぞれ\code{c\_api.h}が公開している\ascii{API}インターフェース：\code{TF\_NewSession/TF\_NewDeprecatedSession}を呼び出します。つまり、自動生成された\code{pywrap\_tensorflow\_internal.cc}は、単に\ascii{Python}関数から\ascii{C/C++}関数呼び出しへの転送を担当し、最終的には下層の\ascii{C}システムが上層に提供する\ascii{API}インターフェースを呼び出します。

\subsection{C API}

\code{c\_api.h}は、\ascii{TensorFlow}のバックエンド実行システムがフロントエンドに公開している公共\ascii{API}インターフェースです。ここで、新しいインターフェース実装では参照カウント技術を採用し、グラフインスタンスを複数の\code{Session}インスタンス間で共有することを実現しています。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
TF_Session* TF_NewSession(TF_Graph* graph, const TF_SessionOptions* opt,
                          TF_Status* status) {
  Session* session;
  status->status = NewSession(opt->options, &session);
  if (status->status.ok()) {
    if (graph != nullptr) {
      mutex_lock l(graph->mu);
      graph->num_sessions += 1;
    }
    return new TF_Session(session, graph);
  } else {
    return nullptr;
  }
}

TF_DeprecatedSession* TF_NewDeprecatedSession(const TF_SessionOptions* opt,
                                              TF_Status* status) {
  Session* session;
  status->status = NewSession(opt->options, &session);
  if (status->status.ok()) {
    return new TF_DeprecatedSession({session});
  } else {
    DCHECK_EQ(nullptr, session);
    return nullptr;
  }
}
\end{c++}
\end{leftbar}

\subsection{バックエンドシステム}

\code{NewSession}は、フロントエンドから渡された\code{target}に基づいて、\code{SessionFactory}を使用して多態的に異なるタイプの\code{tensorflow::Session}インスタンスを作成します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
Status NewSession(const SessionOptions& options, Session** out_session) {
  SessionFactory* factory;
  Status s = SessionFactory::GetFactory(options, &factory);
  if (!s.ok()) {
    *out_session = nullptr;
    return s;
  }
  *out_session = factory->NewSession(options);
  if (!*out_session) {
    return errors::Internal("Failed to create session.");
  }
  return Status::OK();
}
\end{c++}
\end{leftbar}

\subsubsection{ファクトリーメソッド}

バックエンドの\cpp{}実装では、\code{tensorflow::Session}の作成に抽象ファクトリーメソッドを使用しています。\code{SessionOptions}の\code{target}が空文字列（デフォルト）の場合、\code{DirectSession}インスタンスを作成してローカル実行モードを開始します。\code{SessionOptions}の\code{target}が\code{grpc://}で始まる場合、\code{GrpcSession}インスタンスを作成して\code{RPC}ベースの分散実行モードを開始します。\refig{cc-session-factory}に示すとおりです。

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{figures/cc-session-factory.png}
\caption{tensorflow::Sessionの作成：抽象ファクトリーメソッド}
 \label{fig:cc-session-factory}
\end{figure}

\end{content}

\section{グラフの作成/拡張}

\begin{content}

既存のインターフェース実装では、グラフ構築期に構築されたグラフをシリアライズし、バックエンドの\ascii{C++}システムに渡す必要がありました。新しいインターフェース実装では、グラフの作成や拡張を実装する必要はありません。なぜなら、\ascii{OP}の作成時に、ノードがリアルタイムでバックエンドの\ascii{C++}システムのグラフインスタンスに追加されるからです。しかし、既存のインターフェース実装は、システムの動作を理解する上で重要なので、ここで簡単に説明します。

\ascii{Python}フロントエンドは\code{Session.run}インターフェースを反復的に呼び出し、構築された計算グラフを\code{GraphDef}の形式でC++バックエンドに送信します。フロントエンドが\code{Session.run}インターフェースを呼び出すたびに、新しく追加されたノードの計算グラフをバックエンドシステムに送信しようとし、新しく追加されたノードの計算グラフを元の計算グラフに\ascii{Extend}できるようにします。特に、\code{Session.run}を初めて呼び出すときは、計算グラフ全体をバックエンドシステムに送信します。

バックエンドシステムが初めて\code{Session.Extend}を呼び出すとき、\code{Session.Create}に転送（または同等の実装）します。その後、バックエンドシステムが\code{Session.Extend}を呼び出すたびに、実際に\code{Extend}のセマンティクスを実行し、新しく追加された計算グラフのノードを元の計算グラフに追加します。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-session-create-graph.png}
\caption{グラフの作成}
 \label{fig:py-session-create-graph}
\end{figure}

\subsection{プログラミングインターフェース}

既存のインターフェース実装では、\code{\_extend\_graph}を通じてグラフインスタンスの拡張を実現しています。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
class Session(BaseSession):
  def run(self, fetch_list, feed_dict=None, options=None, run_metadata=None):
    # ignores implements...
    self._extend_graph()
    # ignores implements...
\end{python}
\end{leftbar}

\code{self.\_extend\_graph}を初めて呼び出すとき、または新しいノードが計算グラフに追加されたときに、計算グラフ\code{GraphDef}にシリアライズ操作を実行し、最終的に\code{tf\_session.TF\_ExtendGraph}の呼び出しをトリガーします。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
from tensorflow.python import pywrap_tensorflow as tf_session

class Session(BaseSession):
  def _extend_graph(self):
    if self._created_with_new_api: return

    with self._extend_lock:
      if self._graph.version > self._current_version:
        graph_def, self._current_version = self._graph._as_graph_def(
            from_version=self._current_version,
            add_shapes=self._add_shapes)

        with errors.raise_exception_on_not_ok_status() as status:
          tf_session.TF_ExtendGraph(
              self._session, graph_def.SerializeToString(), status)
\end{python}
\end{leftbar}

\subsubsection{Pythonラッパー}

\begin{leftbar}
\begin{python}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.py}]
def TF_ExtendGraph(sess, graph_def, status):
  return _pywrap_tensorflow.TF_ExtendGraph(sess, graph_def, status)
\end{python}
\end{leftbar}

\subsubsection{C++ラッパー}

\begin{leftbar}
\begin{c++}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.cc}]
static PyMethodDef SwigMethods[] = {
  // ignore implements...
  { (char *)"TF_ExtendGraph", 
    _wrap_TF_ExtendGraph, METH_VARARGS, NULL},
};
\end{c++}
\end{leftbar}

\subsection{C API}

\code{TF\_ExtendGraph}は、\ascii{C API}が上層のプログラミング環境と接続するインターフェースです。まず、計算グラフ\code{GraphDef}のデシリアライズを完了し、最終的に\code{tensorflow::Session}の\code{Extend}インターフェースを呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
void TF_ExtendGraph(TF_DeprecatedSession* sess, 
  const void* proto, size_t proto_len, TF_Status* status) {
  GraphDef g;
  if (!tensorflow::ParseProtoUnlimited(&g, proto, proto_len)) {
    status->status = InvalidArgument("Invalid GraphDef");
    return;
  }
  status->status = sess->session->Extend(g);
}
\end{c++}
\end{leftbar}

\subsection{バックエンドシステム}

\code{tensorflow::Session}は実行時に\code{Session}の動的タイプに基づいて、対応するサブクラスの実装を多態的に呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/core/common\_runtime/session.h}]
class Session {
public:
  virtual Status Create(const GraphDef& graph) = 0;
  virtual Status Extend(const GraphDef& graph) = 0;
};
\end{c++}
\end{leftbar}

ここで、\code{Create}は現在の\code{tensorflow::Session}インスタンス上に計算グラフを登録することを表し、新しい計算グラフを登録する場合は、その\code{tensorflow::Session}オブジェクトを閉じる必要があります。\code{Extend}は\code{tensorflow::Session}インスタンス上に既に登録されている計算グラフにノードを追加することを表します。\code{Extend}が初めて実行されるとき、\code{Create}のセマンティクスと同等です。なぜなら、初回の\code{Extend}時には、登録済みの計算グラフが空だからです。実際、システムはこの方式で実装されています。ここでは\code{GrpcSession}の実装を例として挙げます。

\subsubsection{グラフの初回拡張: GrpcSession}

\code{Master}を参照する\code{handle}が空でないと判断された場合、\code{Extend}を実行します。そうでない場合、\code{Create}のセマンティクスを実行し、\code{Master}との接続を確立し、\code{MasterSession}の\code{handle}を保持します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/core/distributed\_runtime/rpc/grpc\_session.cc}]
Status GrpcSession::Extend(const GraphDef& graph) {
  CallOptions call_options;
  call_options.SetTimeout(options_.config.operation_timeout_in_ms());
  return ExtendImpl(&call_options, graph);
}

Status GrpcSession::ExtendImpl
  (CallOptions* call_options, const GraphDef& graph) {
  if (handle_is_empty()) {
    // Session was unitialized, 
    // so simply initialize the session with 'graph'.
    return Create(graph);
  }
  // ignore implements...  
}
\end{c++}
\end{leftbar}

\end{content}

\section{反復実行}

\begin{content}

\refig{py-session-run}に示すように、\ascii{Python}フロントエンドの\code{Session.run}実装は\code{fetches, feed\_dict}をバックエンドシステムに渡し、バックエンドシステムは\code{Session.Run}インターフェースを呼び出します。バックエンドシステムの1回の\code{Session.Run}実行は、しばしば1回の\ascii{Step}と呼ばれます。この\ascii{Step}の実行プロセスは、\ascii{TensorFlow}ランタイムの重要なパスです。

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{figures/py-session-run.png}
\caption{反復実行}
 \label{fig:py-session-run}
\end{figure}

\subsection{プログラミングインターフェース}

\ascii{Client}が\code{Session.run}を呼び出すと、最終的に\code{pywrap\_tensorflow\_internal}モジュール内の関数が呼び出されます。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
from tensorflow.python import pywrap_tensorflow as tf_session

class Session(BaseSession):
  def run(self, fetch_list, feed_dict=None, options=None, run_metadata=None):
    # ignore implements...
    self._extend_graph()
    with errors.raise_exception_on_not_ok_status() as status:
      if self._created_with_new_api:
        return tf_session.TF_SessionRun_wrapper(
            session, options, feed_dict, fetch_list, target_list,
            run_metadata, status)
      else:
        return tf_session.TF_Run(session, options,
                                 feed_dict, fetch_list, target_list,
                                 status, run_metadata)
\end{python}
\end{leftbar}


\subsubsection{Pythonラッパー}

\begin{leftbar}
\begin{python}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.py}]
def TF_SessionRun_wrapper(session, run_options, inputs, 
  outputs, targets, run_metadata, out_status):
  return _pywrap_tensorflow_internal.TF_SessionRun_wrapper(
    session, run_options, inputs, outputs, targets, run_metadata, out_status)

def TF_Run(sess, options, feeds, outputs, 
  targets, status, run_metadata):
  return _pywrap_tensorflow.TF_Run(
    sess, options, feeds, outputs, targets, status, run_metadata)
\end{python}
\end{leftbar}

\subsubsection{C++ラッパー}

\begin{leftbar}
\begin{c++}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.cc}]
static PyMethodDef SwigMethods[] = {
  // ...
  { (char *)"TF_Run", 
    _wrap_TF_Run, METH_VARARGS, NULL},

  { (char *)"TF_SessionRun_wrapper", 
    _wrap_TF_SessionRun_wrapper, METH_VARARGS, NULL},
};
\end{c++}
\end{leftbar}

最終的に、\code{\_wrap\_TF\_Run/\_wrap\_TF\_SessionRun\_wrapper}はそれぞれ\ascii{C API}の対応する\code{TF\_Run/TF\_SessionRun}インターフェース関数を呼び出します。

\subsection{C API}

既存のインターフェースでは、\code{TF\_Run}は\ascii{C API}が上位のプログラミング環境と接続するインターフェースです。まず、入力データを\ascii{C}から\cpp{}の形式に変換し、バックグラウンドの\code{tensorflow::Session}の実行プロセスを開始します。実行が完了すると、\code{outputs}の出力データを\cpp{}から\ascii{C}の形式に再変換します。\code{TF\_SessionRun}は\code{TF\_Run}とほぼ同じ動作メカニズムを持つため、ここでは詳細な説明は省略します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
void TF_Run(TF_DeprecatedSession* s, 
  // session options
  const TF_Buffer* run_options,
  // Input tensors
  const char** c_input_names, TF_Tensor** c_inputs, int ninputs,
  // Output tensors
  const char** c_output_names, TF_Tensor** c_outputs, int noutputs,
  // Target nodes
  const char** c_target_oper_names, int ntargets,
  // run\_metadata
  TF_Buffer* run_metadata, TF_Status* status) {
  // convert data format, ignore implements...
  s->session->Run(options_proto, input_names, output_names,
                  target_names, &outputs, &run_metadata); 
  // store results in c\_outputs...
}

void TF_SessionRun(TF_Session* session, 
  const TF_Buffer* run_options,
  // Input tensors
  const TF_Output* inputs, TF_Tensor* const * input_values, int ninputs, 
  // Output tensors
  const TF_Output* outputs, TF_Tensor** output_values, int noutputs,
  // Target nodes
  const TF_Operation* const* target_opers, int ntargets,
  // run\_metadata
  TF_Buffer* run_metadata, TF_Status* status) {
  // ignore implements.
}
\end{c++}
\end{leftbar}

\subsection{バックエンドシステム}

\code{tensorflow::Session}は実行時にその動的タイプに応じて、対応するサブクラスの実装を多態的に呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/core/common\_runtime/session.h}]
class Session {
public:
  virtual Status Run(
    const RunOptions& options,
    const vector<pair<string, Tensor> >& inputs,
    const vector<string>& output_names,
    const vector<string>& target_names,
    vector<Tensor>* outputs, RunMetadata* run_metadata) {
      return errors::Unimplemented(
        "Run with options is not supported for this session.");
  }
};
\end{c++}
\end{leftbar}

入力には以下が含まれます：

\begin{enum}
  \eitem{\code{options}：\code{Session}の実行設定パラメータ；}
  \eitem{\code{inputs}: 入力\code{Tensor}の名前リスト；}
  \eitem{\code{output\_names}: 出力\code{Tensor}の名前リスト；}
  \eitem{\code{targets}: 出力のない、実行すべき\ascii{OP}の名前リスト。} 
\end{enum}

出力には以下が含まれます：

\begin{enum}
  \eitem{\code{outputs}: 出力\code{Tensor}のリスト；}
  \eitem{\code{run\_metadata}: 実行時メタデータのコレクター。}
\end{enum}

ここで、出力の\code{outputs}リストは入力の\code{output\_names}と一対一で対応しています。実行時に並行実行によって\code{outputs}が乱順に実行された場合、最終的な返却時には入力の\code{output\_names}名前リストと照合して\code{outputs}をソートする必要があります。

\end{content}

\section{セッションの終了}

\begin{content}

計算グラフの実行が完了したら、\code{tf.Session}を終了して、バックエンドのシステムリソース（キュー、\ascii{IO}など）を解放する必要があります。セッション終了のフローは比較的シンプルで、\refig{py-session-close}に示すとおりです。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-session-close.png}
\caption{セッションの終了}
 \label{fig:py-session-close}
\end{figure}

\subsection{プログラミングインターフェース}

\ascii{Client}が\code{Session.close}を呼び出すと、最終的に\code{pywrap\_tensorflow}モジュール内の関数：\code{TF\_CloseDeprecatedSession}が呼び出されます。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]
from tensorflow.python import pywrap_tensorflow as tf_session

class Session(BaseSession):
  def close(self):
    if self._created_with_new_api:
      if self._session and not self._closed:
        self._closed = True
        with errors.raise_exception_on_not_ok_status() as status:
          tf_session.TF_CloseSession(self._session, status)
    else:
      with self._extend_lock:
        if self._opened and not self._closed:
          self._closed = True
          with errors.raise_exception_on_not_ok_status() as status:
            tf_session.TF_CloseDeprecatedSession(self._session, status)
\end{python}
\end{leftbar}

\subsubsection{Pythonラッパー}

\begin{leftbar}
\begin{python}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.py}]
def TF_CloseSession(sess, status):
    return _pywrap_tensorflow_internal.TF_CloseSession(sess, status)

def TF_CloseDeprecatedSession(sess, status):
  return _pywrap_tensorflow.TF_CloseDeprecatedSession(sess, status)
\end{python}
\end{leftbar}

\subsubsection{C++ラッパー}

\code{\_wrap\_TF\_CloseSession/\_wrap\_TF\_CloseDeprecatedSession}は、それぞれ\ascii{C API}の対応する\code{TF\_CloseSession/TF\_CloseDeprecatedSession}インターフェース関数を呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.cc}]
static PyMethodDef SwigMethods[] = {
  // ...
  { (char *)"TF_CloseSession", 
    _wrap_TF_CloseSession, METH_VARARGS, NULL},

  { (char *)"TF_CloseDeprecatedSession", 
    _wrap_TF_CloseDeprecatedSession, METH_VARARGS, NULL},
};
\end{c++}
\end{leftbar}

\subsection{C API}

\code{TF\_CloseSession/TF\_CloseDeprecatedSession}は直接\code{tensorflow::Session}の終了操作を完了します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
void TF_CloseSession(TF_Session* s, TF_Status* status) {
  status->status = s->session->Close();
}

void TF_CloseDeprecatedSession(TF_DeprecatedSession* s, TF_Status* status) {
  status->status = s->session->Close();
}
\end{c++}
\end{leftbar}

\subsection{バックエンドシステム}

\code{Session(C++)}は実行時にその動的タイプに応じて、対応するサブクラスの実装を多態的に呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/core/common\_runtime/session.h}]
class Session {
public:
  virtual Status Close() = 0;
};
\end{c++}
\end{leftbar}

\end{content}

\section{セッションの破棄}

\begin{content}

\code{tf.Session}が使用されなくなると、\ascii{Python}の\ascii{GC}によって解放されます。\code{Session.\_\_del\_\_}が呼び出された後、バックグラウンドの\code{tensorflow::Session}オブジェクトの破棄プロセスが開始されます。\refig{py-delete-session}に示すとおりです。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/py-delete-session.png}
\caption{セッションの破棄}
 \label{fig:py-delete-session}
\end{figure}

\subsection{プログラミングインターフェース}

\ascii{Client}が\code{Session.\_\_del\_\_}を呼び出すと、まず\code{Session.close}の呼び出しが開始され、最終的に\code{pywrap\_tensorflow}モジュール内の関数\code{TF\_DeleteSession/TF\_DeleteDeprecatedSession}が呼び出されます。

\begin{leftbar}
\begin{python}[caption={tensorflow/python/client/session.py}]

from tensorflow.python import pywrap_tensorflow as tf_session

class Session(BaseSession):
  def __del__(self):
    # 1. close session unconditionally.
    try:
      self.close()
    except Exception:
      pass
    # 2. delete session unconditionally.
    if self._session is not None:
      try:
        status = c_api_util.ScopedTFStatus()
        if self._created_with_new_api:
          tf_session.TF_DeleteSession(self._session, status)
        else:
          tf_session.TF_DeleteDeprecatedSession(self._session, status)
      except AttributeError:
        pass
      self._session = None
\end{python}
\end{leftbar}

\subsubsection{Pythonラッパー}

\begin{leftbar}
\begin{python}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.py}]
def TF_DeleteSession(sess, status):
    return _pywrap_tensorflow_internal.TF_DeleteSession(sess, status)

def TF_DeleteDeprecatedSession(sess, status):
  return _pywrap_tensorflow.TF_DeleteDeprecatedSession(sess, status)
\end{python}
\end{leftbar}

\subsubsection{C++ラッパー}

\code{\_wrap\_TF\_DeleteSession/\_wrap\_TF\_DeleteDeprecatedSession}は、それぞれ\ascii{C API}の対応する\code{TF\_DeleteSession/TF\_DeleteDeprecatedSession}インターフェース関数を呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/bazel-bin/tensorflow/python/pywrap\_tensorflow\_internal.cc}]
static PyMethodDef SwigMethods[] = {
  // ...
  { (char*)"TF_DeleteSession", 
    _wrap_TF_DeleteSession, METH_VARARGS, NULL},

  { (char*)"TF_DeleteDeprecatedSession", 
    _wrap_TF_DeleteDeprecatedSession, METH_VARARGS, NULL},
};
\end{c++}
\end{leftbar}

\subsection{C API}

\code{TF\_DeleteDeprecatedSession}は直接\code{tensorflow::Session}オブジェクトの解放を完了します。一方、新しいインターフェース\code{TF\_DeleteSession}の実装では、\code{tensorflow::Session}インスタンスを削除する必要がある場合、対応するグラフインスタンスのカウンターを1減らします。カウンターが0になった場合、そのグラフインスタンスを削除します。そうでない場合は、そのグラフインスタンスを削除しません。

\begin{leftbar}
\begin{c++}[caption={tensorflow/c/c\_api.c}]
void TF_DeleteSession(TF_Session* s, TF_Status* status) {
  status->status = Status::OK();
  TF_Graph* const graph = s->graph;
  if (graph != nullptr) {
    graph->mu.lock();
    graph->num_sessions -= 1;
    const bool del = graph->delete_requested && graph->num_sessions == 0;
    graph->mu.unlock();
    if (del) delete graph;
  }
  delete s->session;
  delete s;
}

void TF_DeleteDeprecatedSession(TF_DeprecatedSession* s, TF_Status* status) {
  status->status = Status::OK();
  delete s->session;
  delete s;
}
\end{c++}
\end{leftbar}

\subsection{バックエンドシステム}

\code{tensorflow::Session}は実行時にその動的タイプに応じて、対応するサブクラスの実装のデストラクタを多態的に呼び出します。

\begin{leftbar}
\begin{c++}[caption={tensorflow/core/common\_runtime/session.h}]
class Session {
public:
  virtual ~Session() {};
};
\end{c++}
\end{leftbar}

\end{content}

\section{パフォーマンスチューニング}

\begin{content}

従来のインターフェース実装と比較して、新しいインターフェース実装にはシステムのパフォーマンスを向上させるいくつかの最適化技術が存在します。本書執筆時点では、新しいインターフェースはまだ完全に公開されていませんが、将来的には既存の非推奨インターフェースが削除され、新しいインターフェース実装に置き換えられることが予想されます。

\subsection{グラフインスタンスの共有}

\refig{tf-graph-session-relation}に示すように、1つの\code{Session}は1つのグラフインスタンスのみを実行できます。\code{Session}が他のグラフインスタンスを実行する必要がある場合、まず\code{Session}を閉じ、その後新しいグラフインスタンスをこの\code{Session}に登録し、最後に新しい計算グラフの実行プロセスを開始する必要があります。

しかし逆に、1つの計算グラフは複数の\code{Session}インスタンス上で実行できます。\code{Graph}インスタンス上で\code{Session}の参照カウンタを維持し、\code{Session}作成時にそのグラフインスタンス上のカウンタを1増やし、\code{Session}破棄時（\code{Session}の終了ではない）にそのグラフインスタンス上のカウンタを1減らし、カウンタが0になったときに自動的にグラフインスタンスを削除するという方法が考えられます。新しいインターフェース実装では、この参照カウンタ技術が実装されています。

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{figures/tf-graph-session-relation.png}
\caption{計算グラフ：Session参照カウンタ技術}
 \label{fig:tf-graph-session-relation}
\end{figure}

\subsection{シリアライゼーションの排除}

\refig{tf-old-session-interface}に示すように、従来のインターフェース実装では、フロントエンドの\ascii{Python}がグラフ構築期にグラフを構築した後、それをシリアライズし、最後に\code{Session::Create}または\code{Session::Extend}を通じてバックエンドの\ascii{C++}システムに渡していました。これは本質的にグラフインスタンスのコピープロセスであり、大きな遅延オーバーヘッドを持っています。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/tf-old-session-interface.png}
\caption{グラフインスタンス：シリアライゼーション/デシリアライゼーション}
 \label{fig:tf-old-session-interface}
\end{figure}

\refig{tf-new-session-interface}に示すように、新しいインターフェース実装では、\code{Session}の\code{Create/Extend}のセマンティクスを削除することができます。グラフのコンストラクタにおいて、フロントエンドの\ascii{Python}が各\ascii{OP}を構築する際に、直接\ascii{C API}を通じてバックエンドの\ascii{C++}のグラフインスタンスに追加することで、グラフインスタンスのフロントエンドとバックエンド間のシリアライゼーションとデシリアライゼーションのオーバーヘッドを回避しています。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/tf-new-session-interface.png}
\caption{グラフインスタンス：\ascii{OP}の実際の登録}
 \label{fig:tf-new-session-interface}
\end{figure}

\end{content}
