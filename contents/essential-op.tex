\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

```latex
\begin{savequote}[45mm]
\ascii{コンピュータが理解できるコードを書くのは誰にでもできる。優秀なプログラマーは人間が理解できるコードを書く。}
\qauthor{\ascii{- マーティン・ファウラー}}
\end{savequote}

\chapter{OPの本質論} 
\label{ch:essential-op}

\begin{content}

\end{content}

\section{OPの登録}

\begin{content}

C++バックエンドシステムでは、システム初期化時にすべてのOPの登録が完了します。OPの登録は\code{REGISTER\_OP}マクロを通じて行われます。

\subsection{REGISTER\_OP}

実装上、\code{REGISTER\_OP}は洗練された内部DSLのセットを定義し、システムは自動的に文字列表現の変換表現を完了し、それを\code{OpDef}の内部表現に変換し、最終的に\code{OpDef}のリポジトリに保存します。

\begin{figure}[!h]
\centering
\includegraphics[width=0.9\textwidth]{figures/cc-op-repo.png}
\caption{REGISTER\_OP：OPを登録する実用的なマクロ}
 \label{fig:cc-op-repo}
\end{figure}

\subsection{クエリインターフェース}

\begin{leftbar}
\begin{c++}
struct OpRegistryInterface {
  virtual ~OpRegistryInterface() {}

  virtual Status LookUp(
    const string& op_name,
    const OpRegistrationData** op_reg_data) const = 0;
  Status LookUpOpDef(const string& op_name, const OpDef** op_def) const;
};
\end{c++}
\end{leftbar}

ここで、\code{OpRegistrationData}はOPの2つの基本的なメタデータを記述しています：\code{OpDef}と\code{OpShapeInferenceFn}です。前者はOPの入力/出力パラメータ情報、属性名リスト、およびその制約関係を記述するために使用されます。後者はOPのShapeの推論ルールを記述するために使用されます。

\begin{leftbar}
\begin{c++}
struct OpRegistrationData {
  OpDef op_def;
  OpShapeInferenceFn shape_inference_fn;
};

using OpRegistrationDataFactory = 
  std::function<Status(OpRegistrationData*)>;
\end{c++}
\end{leftbar}

\subsection{OpDefリポジトリ}

実装では、遅延初期化の技術が採用されています。問題の説明を簡単にするために、ここでは簡単なコードリファクタリングを行い、\code{OpRegistry}の動作原理を理解しやすくしています。

\begin{leftbar}
\begin{c++}
struct OpRegistry : OpRegistryInterface {  
  OpRegistry();
  ~OpRegistry() override;

  void Register(const OpRegistrationDataFactory& factory);

 private:
  Status LookUp(
     const string& op_name,
     const OpRegistrationData** op_reg_data) const override;

 private:
  using Registry = 
    std::unordered_map<string, OpRegistrationData*>;

  mutex mu_;
  Registry registry_;
};
\end{c++}
\end{leftbar}

\begin{leftbar}
\begin{c++}
Status OpRegistry::Register(
  const OpRegistrationDataFactory& factory) {
  auto op_reg_data(std::make_unique<OpRegistrationData>());
  Status s = factory(op_reg_data.get());
  if (s.ok()) {
    gtl::InsertIfNotPresent(&registry_, 
      op_reg_data->op_def.name(),
      op_reg_data.get())
  }
  if (s.ok()) {
    op_reg_data.release();
  } else {
    op_reg_data.reset();
  }
  return watcher_status;
}
\end{c++}
\end{leftbar}

\end{content}

